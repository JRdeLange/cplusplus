<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<title> C/C++ Exercises </title>
<style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
    .XXfc {margin-left:auto;margin-right:auto;}
    .XXtc {text-align: center;}
    .XXtl {text-align: left;}
    .XXtr {text-align: right;}
    .XXvt {vertical-align: top;}
    .XXvb {vertical-align: bottom;}
</style>
</head>
<body cz-shortcut-listen="true">
<hr>
<ul>
    <li> <a href="https://www.icce.rug.nl/edu/1/opgaven.html">Table of Contents</a>
    </li><li> <a href="https://www.icce.rug.nl/edu/1/opgaven02.html">Next Chapter</a>
</li></ul>
<hr>
<a name="l1"></a>
<h1>Chapter 1: Set one: Introduction. Deadline: September 19</h1>
            <br><br>
<p>

<strong>PRELIMINARIES</strong>
</p><p>
</p><ul>
<p>
</p><li> Closely follow the <a href="https://www.icce.rug.nl/edu/1/hints.shtml">hints and tips</a>. They are updated
almost every week, and not adhering to the suggestions we present present
there needlessly reduces your ratings.
<p>

</p></li><li> 
<p>
<strong>NOTE WELL:</strong>
 If your lines of code are too long for the paper's width then <em>don't</em> let
the printer do the line-wrapping for you, as that screws up the layout (or
worse: lines may be cut off at the paper's right margin). Instead, format long
lines yourself, making sure they come out nicely. Sources are rated the way
they are received, and if we see sources that won't compile then their
exercise is rated as 0.
</p><p>
</p></li><li> When output needs to be presented as part of an exercise, use
<em>redirection</em> at the operating system level to send the output to file:
        <pre>
    program &gt; out
        
</pre>

    The program's output is now written on the file <code>out</code> which can be
edited and printed.
<p>
</p></li><li> When submitting exercises, <strong>Always briefly summarize the question
before presenting your answer</strong>. If a question has several itemized
sub-questions, use the itemized format in your answer as well (summarize the
question per item, which is then followed by your answer).
<p>
</p></li><li> You earn points (usually 1 point) for each correctly completed
exercise, or a lower number of points (down to half a point) when an exercise
is not considered fully OK.
<p>
</p></li><li> Exercises for which you did not receive the maximum ratings may be
resubmitted <strong>ONCE</strong>, but only <em>before their deadlines</em>. <em>Never</em> 
resubmit exercises that received their maximum possible ratings.
<p>
</p></li><li> For all exercises: submit all sources you wrote to complete the
exercise, unless indicated otherwise.
<p>
</p></li><li> <strong>Mind the layout!</strong>
<p>
</p></li><li> You're free (and encouraged) to submit optional exercises (marked
`(optional)'). Their weight in the exercise-count equals their rating. E.g.,
if the rating equals <code>'?'</code> (half a point) then 0.5 is added to the number of
answered exercises. Therefore, submitting optional exercises <em>never</em> lowers
your percentage, as
    <pre>
            (x + d) / (y + d) &gt;= x / y
    
</pre>

    if d and x are non-negative, and x &lt; y. 
<p>
</p></li><li> Answers to exercises are provided at the exercises once their
deadlines have been reached. Even if you didn't submit all exercises,
<em>study</em> their answers as they may show you how problems can be
solved. Frequently the results of earlier exercises are used for later
exercises and having studied answers to exercises makes it easier to find
solutions to later exercises.
<p>
</p></li><li> If an exercise is formulated such that it requires results from
another exercise, you may assume that those results <em>are</em> available and
<em>are working properly</em>. Submitting sources is of course not required if an
exercise explicitly says so. Otherwise you should always submit all the
sources you wrote for that exercise.
<p>
</p></li></ul>
<p>
<strong>ASSIGNMENTS</strong>
</p><p>
You may find the first set of basic assignments fairly easy to complete. Don't
let this fool you into thinking that that's the way it'll remain. Rather: grab
the easy points to provide you with a head start!
</p><p>
<em>Always</em> provide your statements with short explanatory (end-of-line)
comments briefly stating the meaning of the statement. Make sure your comment
is visually separated from the statement itself. Do not `glue' it to the
statement but let it start half-way the width of a standard screen,
e.g. at/after column 40. E.g.,
        </p><pre>
    usage();                    // show a short usage guide; end the program
        
</pre>

    If the statement itself is wide, then either write the comment in the
immediately preceding line, or spread  the statement over multiple
lines. E.g.,
        <pre>
    options(                    // handle all options
        "ab:cDe:", argc, argv, 
        longOptBegin, longOptEnd
    );
        
</pre>

<p>
</p><hr>
        <strong>Exercise 1.</strong>
        <br>
        Basic exercise
        <br>
        Purpose of this exercise: construct a famous program illustrating that you
can use the compiler.
<p>
This is an exeercise to get you `up and running'.  Its main purpose is to show
(also to yourself) that you have an operational compiler and that you're able
to write the most famous of all C/C++ programs:
</p><p>
Construct a program printing the text 
        </p><pre>
    Hello World
        
</pre>

    to the screen. The line must properly be terminated (use <code>\n</code>).
<p>
Name your source file 
        </p><pre>
    hello.cc
        
</pre>

    Compile and link the program.
<p>
Construct the separate object file <code>hello.o</code>, and the executable program 
<code>hello.exe</code> (Windows) or  <code>hello</code> (Unix). Provide short, informative
descriptions of what these two files are.
</p><p>
Submit:
    </p><ul>
    <li>  the listing (of course, see the introductory text above this
exercise) of your program;
    </li><li> The commands you entered to compile and link the program;
    </li><li> The short descriptions of object file and executable;
    </li><li> The program's output;
    </li><li> The size in bytes (not kBytes!) of:
        <ul>
            <li> the source file;
            </li><li> the object file;
            </li><li> the executable program (<em>strip</em> it first, using the <code>-s</code>
    switch when creating the executable);
            </li><li> the file <code>iostream</code>
        </li></ul>
    </li></ul>
<p>
Note that the size of the files depends on the used operating system and
compiler.
</p><p>
For the file  <code>iostream</code> it's important to find its location. Even the
way to find files like <code>iostream</code> depends on operating system and compiler.
</p><p>
On my <strong>Linux</strong> system the standard <strong>C</strong> headers are found in 
directory <code>/usr/include</code>, while the standard <strong>C++</strong> headers are below
<code>/usr/include/c++</code>. In there the file <code>iostream</code> is found. 
</p><p>
Alternatively, the <code>locate</code> program can be used: the command
        </p><pre>
    locate iostream
        
</pre>

    will tell you where the <code>iostream</code> files are. I count about 200 hits....
However,
        <pre>
    locate iostream | grep '\biostream$'
        
</pre>

    reduces this to four, among which  <code>/usr/include/c++/4.1.3/iostream</code>: 
bingo! 
<p>
Under Windows 
        </p><pre>
    Find -&gt; Files or Folders
        
</pre>
 
    allows you to find a certain file. Alternatively (and preferably), use
        <pre>
    find / -name iostream
        
</pre>

    when you're using Linux.
<p>
<br><strong>Answer:</strong><br></p><pre>
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; "Hello world\n";       // show message on the screen
}    

/*
    hello.cc:   Source file of the C++ program
    hello.o:    Object file: compiled code, not linked to library functions
                    like printf()
    hello[.exe] Executable program

    On my system there exists:
        /usr/include/g++-v3/iostream
    The location of this file and the sizes of the files might vary over 
    different systems.
    
    Output:     Hello world 

    Compiled using: 

                g++ -c -Wall hello.cc
                g++ -o hello hello.o
*/

</pre>

<p>
Depending on what you wrotee into your source file and what compiler you used
your answer may differ from the values shown below.
</p><p>
The size in bytes of 
    </p><ul>
        <li> the source file:   587 bytes 
        </li><li> the object file:   1900 bytes
        </li><li> the executable program:    7846, stripped: 4000 bytes.
        </li><li> the file <code>iostream</code>: 2962 bytes
    </li></ul>
<p>
<br><br>
    
</p><hr>
        <strong>Exercise 2.</strong>
        <br>
        Basic exercise
        <br>
            Purpose of this exercise:
understand several core concepts that are frequently used when constructing
<strong>C++</strong> programs.
<p>
Give short (1-2 sentences) answers to the following questions
    </p><ul>
    <li> In <strong>C++</strong>, what's the difference between a declaration and a
definition?
    </li><li> What are  header files used for?
    </li><li> When a compiler creates a program, in what part of the construction
process does it use  header files and in what part libraries? (Try to answer
the question why the compiler uses header files and libraries.)
    </li><li> Is a library an object module? Provide an explanation, not just
<em>yes</em> or <em>no</em>.
    </li><li> Why is an object module obtained after compiling a source
containing <code>int main()</code> not an executable program?
    </li></ul>
<p>
Note: when answering this exercise, if you feel the need for using terminology
like `independently relocatable code', (we're not suggesting you should!) then
that's nice, but please in that case, also explain what you mean by that.
</p><p>
<br><strong>Answer:</strong><br>
    </p><ul>
    <li> A declaration is used to inform the compiler that an entity
(variable, object, function) exists; a definition tells the compiler to
actually set aside some memory for the defined entity.
    </li><li> A header file contains declarations. A well-designed header file
<em>never</em> contains definitions.
    </li><li> Header files are used in the compilation phase of a program. Once
compiled, the declared entities must actually become available. One way to do
this is to obtain them from libraries. Libraries are used in the linking phase
of a program. So-called `dynamic link libraries' are also used when the
program is run, to obtain the required entities when they are actually needed.
    </li><li> A library is not an object module, but it contains one or more object
modules. It's therefore a kind of archive. Object modules are usually combined
together to form an executable program. Object modules can also be stored in a
library. When the binary program is created by the `linker' it combines object
modules and may use libraries to obtain all entities declared by the object
modules from object modules found in the libraries.
    </li><li> An object module contains executable code and several tables
containing references to code used by the executable code. An object module is
at best some kind of `incomplete program'. In an executable program all
required entities are available. One of these required entities is the
`run-time support system' (RSS), responsible for satisfying all requirements
(e.g., setting up a <em>stack</em>; making sure there's enough memory to run the
program) of the program. Once these requirements are fullfilled, the RSS will
call the <code>main()</code> function to execute the programmer-defined part of the
program.
    </li></ul>
<p>
<br><br>
    
</p><hr>
        <strong>Exercise 3.</strong>
        <br>
        Basic exercise
        <br>
        Purpose of this exercise: learn to recognize some standard <strong>C++</strong> elements.
<p>
Of the following examples, indicate which are valid <strong>C++</strong> code snippets, and
if not how they can be fixed (or at least indicate why the snippet isn't
considered valid <strong>C++</strong>).
</p><p>
Note: <em>valid</em> in this context not only means that the snippet is accepted by
the compiler, but also that it's considered standard or good <strong>C++</strong> practice.
</p><p>
</p><ol>
    <li>   This is a valid <strong>C++</strong> program:
        <pre>
int main()
{}
        
</pre>

<p>
</p></li><li> This is a valid <strong>C++</strong> program:
        <pre>
int main(int argc, char *argv[], char *envp[])
{}
        
</pre>

<p>
</p></li><li> This is a valid <strong>C++</strong> program:
        <pre>
int main(int argc, char *argv[])
{
    return;
}
        
</pre>

<p>
</p></li><li> <pre>sizeof('c') == 1
</pre>

<p>
</p></li><li> In <code>main(int argc, char *argv[])</code> it is true that <code>argv[argc] ==
        0</code>.  
<p>
</p></li><li> To immediately end a program from deep inside its code <code>exit(0)</code>
        should be used.
<p>
</p></li><li> When defining an enum called <code>Name</code> start with <code>enum Name</code>,
        instead of using <code>typedef enum Name</code>.
<p>
</p></li><li> When writing <code>argv[2][3]</code> the index <code>[2]</code> is evaluated before
        index <code>[3]</code>. 
    </li></ol>
<p>
<br><strong>Answer:</strong><br>
</p><p>
</p><ol>
    <li>   Correct:<br>
         This is a valid <strong>C++</strong> program:
        <pre>
int main()
{}
        
</pre>

<p>
</p></li><li> Incorrect:<br>
        This is a valid <strong>C++</strong> program:
        <pre>
int main(int argc, char *argv[], char *envp[])
{}
        
</pre>

    the 3rd (environment) parameter is not supported.
<p>
</p></li><li> Incorrect:<br>
        This is a valid <strong>C++</strong> program:
        <pre>
int main(int argc, char *argv[])
{
    return;
}
        
</pre>

        The <code>return</code> statement must be provided with a value (e.g.,
        <code>return 0;</code>).
<p>
</p></li><li> Correct: <pre>sizeof('c') == 1
</pre>

<p>
</p></li><li> Correct: in <code>main(int argc, char *argv[])</code> it is true that
        <code>argv[argc] == 0</code>.  
<p>
</p></li><li> Incorrect: to immediately end a program from deep inside its code
        <code>exit(0)</code> should be used.<br>
        Using <code>exit</code> is deprecated.
<p>
</p></li><li> Correct: when defining an enum called <code>Name</code> start with <code>enum
        Name</code>, instead of using <code>typedef enum Name</code>.
<p>
</p></li><li> Correct: when writing <code>argv[2][3]</code> the index <code>[2]</code> is evaluated
        before index <code>[3]</code>.
    </li></ol>
<p>
<br><br>
    
</p><hr>
        <strong>Exercise 4.</strong>
        <br>
        Basic exercise
        <br>
        Purpose of this exercise: learn to use Raw String Literals
<p>
The following example shows how several NTBs, and some character constants
are inserted into the output stream.
</p><p>
Remove the NTBs and transform them into one Raw String
Literals (RSLs) (assume <code>iostream</code> has been included).
</p><p>
</p><pre>
    std::cout &lt;&lt; "^\\s+Encryption key:(\\w+)"        &lt;&lt; '\n' &lt;&lt; 
                 "^\\s+Quality=(\\d+)"               &lt;&lt; '\n' &lt;&lt;
                 "^\\s+E?SSID:\"([[:print:]]+)\""    &lt;&lt; '\n' &lt;&lt;
                 "^\\s+ssid=\"([[:print:]]+)\""      &lt;&lt; '\n';

</pre>

<p>
Submit your implementation as a working <strong>C++</strong> program. Also submit the
output it produces.
</p><p>
Hints: 
    </p><ul>
    <li> use the insertion operator only once.
    </li><li> as outlined in the hints and tips: define raw string literals outside
of your <code>main</code> function body, and use the raw string's variable name in the
<code>cout</code> statement.
    </li><li> when solving the exercise you'll notice that you won't be able to use
the <code>R"(...)"</code> form of the RSLs. Formulate (submit) a rule telling you when
this form can and cannot be used.
    </li></ul>
<p>
<br><strong>Answer:</strong><br>
</p><p>
</p><ul>
<p>
</p><li> Consider abandoning indentation when using multi-line RSLs, as shown
below. The raw string's label '1' is used to avoid interpretation of )"
in the string text itself as the end of the RSL.
<p>
</p><pre>
#include &lt;iostream&gt;

char const code[] =                 // 'code' holds the string's contents
R"1(^\s+Encryption key:(\w+)        
\s+Quality=(\d+)
^\s+E?SSID:"([[:print:]]+)"
^\s+ssid="([[:print:]]+)"
)1";                                // newline: RSL's ends on separate line

int main()
{
    std::cout &lt;&lt; code;              // display the RSL on the screen
}

</pre>

<p>
</p></li><li> The form <code>R"(...)"</code> can only be used if the contents of the string does
not contain the character combination <code>)"</code>, as this would prematurely
end the RSL. In those situations a label must be used, like
<code>R"label(...)label"</code>, where <code>)label"</code> is a sequence of characters
not encounterd earlier in the string contents itself.
</li></ul>
<p>
<br><br>
    
</p><hr>
        <strong>Exercise 5.</strong>
        <br>
        Basic exercise
        <br>
            Purpose of this exercise:
understand the `piping' and `redirection' concepts.
<p>
Explain in your own words the meaning of <em>redirection</em> and
<em>piping</em>. In particular, explain what happens in
        </p><pre>
    program &lt; in &gt; out
        
</pre>

    and
        <pre>
    program | less
        
</pre>

<p>
<br><strong>Answer:</strong><br>
        </p><pre>
    program &lt; in &gt; out
        
</pre>

    <code>program</code> will read its standard input stream from the <em>file</em> <code>in</code>,
and will write its standard output to the <em>file</em> <code>out</code>.
        <pre>
    program | less
        
</pre>

    <code>program</code> will write its standard output not to the screen, but to the
standard input stream of the program <code>less</code>. Two processes are involved
here: <code>program</code>, producing output, <code>less</code>, consuming the output produced
by <code>program</code>.
<p>
<br><br>
    
</p><p>
</p><hr>
        <strong>Exercise 6.</strong>
        <br>
        Advanced exercise
        <br>
        Purpose of this exercise: get some experience in using various operators
<p>
Is an unsigned value odd or even? In this exercise define a <code>main</code> function,
reading an unsigned integral value from <code>cin</code> (use the extraction operator:
<code>cin &gt;&gt; value</code>).
</p><p>
Then, provide six <code>cout</code> statements of the form
    </p><pre>
    cout &lt;&lt; (expression ? "odd" : "even") &lt;&lt; '\n';
    
</pre>

    (optionally you may swap the <code>odd</code> and <code>even</code> NTBSs.) Here, 
<code>expression</code> is a <strong>C++</strong> expression to determine whether the variable that
was just extracted from <code>cin</code> is either odd or even.
<p>
Notes:
    </p><ul>
    <li> except for the <code>==</code>, the ternary operator, and the insertion
operator, operators may be used only once. So, if an expression uses the <code>+</code>
operator, it may not be used again in any of the other expressions;
    </li><li> with each statement provide a short semantic comment explaining why
the expression correctly performs its task;
    </li><li> Assuming your layout is OK, then you must provide five expressions
for a <code>?</code>-rating, and six expressions for a <code>1</code>-rating.
    </li><li> You may only define one (<code>size_t value</code>) variable.
    </li><li> Hint: use <code>using namespace std;</code> before <code>main's</code> definition so
you can avoid writing the <code>std::</code> namespace designators.
    </li></ul>
<p>
Submit your program.
</p><p>
<br><strong>Answer:</strong><br>
    </p><pre>#include &lt;iostream&gt;

using namespace std;

int main()
{
    size_t value;

    cin &gt;&gt; value;

                            // odd if the least significant bit (lsb) was set
    cout &lt;&lt; (value &amp; 1 ? "odd" : "even") &lt;&lt; '\n';

                            // same idea: set the lsb. If already set then
                            // odd.
    cout &lt;&lt; ((value | 1) == value ? "odd" : "even") &lt;&lt; '\n';

                            // toggle the lsb. If odd: 1 -&gt; 0, and so the
                            // resulting value equals value - 1. If even: 0 -&gt;
                            // 1 which is completely different from
                            // value - 1
    cout &lt;&lt; ((value ^ 1) == value - 1 ? "odd" : "even") &lt;&lt; '\n';

                            // when odd, the lsb is lost when multiplying by 2
                            // after dividing by 2
    cout &lt;&lt; (value / 2 * 2 == value ? "even" : "odd") &lt;&lt; '\n';

                            // odd if division by 2 has a remainder of 1
    cout &lt;&lt; (value % 2 ? "odd" : "even") &lt;&lt; '\n';

                            // same as / and *, but using shifts instead of 
                            // multiplication operators
    cout &lt;&lt; (value &gt;&gt; 1 &lt;&lt; 1 == value ? "even" : "odd") &lt;&lt; '\n';

}


    
</pre>

<p>
<br><br>
    
</p><hr>
        <strong>Exercise 7.</strong>
        <br>
        Advanced exercise
        <br>
        Purpose of this exercise: learn to simplify bit-field operations
<p>
Write a program initializing a <code>size_t value</code> field of a <code>union</code>
as follows:
    </p><ul>
    <li> it holds an even value;
    </li><li> bits 1 through 3 (bit counting starts at 0) hold the value 7
    </li><li> the next 4 bits hold the value 15
    </li><li> the next 5 bits hold the value 10
    </li><li> the next 4 bits hold the value 6
    </li><li> the next 4 bits hold the value 7
    </li><li> the next 4 bits hold the value 15
    </li><li> the next 4 bits hold the value 15
    </li><li> the next 4 bits hold the value 7
    </li><li> the next 5 bits hold the value 0
    </li><li> the next 2 bits hold the value 3
    </li><li> the remaining bits are not set
    </li></ul>
<p>
Display the variable as a hexadecimal value (use <code>cout &lt;&lt; hex &lt;&lt; ...</code> for
that). 
</p><p>
Your <code>main</code> function may only contain one <code>cout</code> statement, and your
program may not define global variables.
</p><p>
Hint: use bit-fields
</p><p>
Submit your program and its output.
</p><p>
<strong>Note:</strong>
</p><p>
This exercise assumes that you're working on a little-endian computer. Most
computers are, but maybe some computers use big endian multi-byte
representations. If you don't know and want to verify what your computer uses,
run the following little program:
</p><p>
</p><pre>    #include &lt;arpa/inet.h&gt;

    #include &lt;iostream&gt;

    using namespace std;

    int main()
    {
        uint32_t value = 0x10203040;

        cout &lt;&lt; hex &lt;&lt; value &lt;&lt; ' ' &lt;&lt; htonl(value) &lt;&lt; '\n';
    }

</pre>

<p>
If the two values that are displayed when you execute the program are equal
then you're using a big-endian computer, otherwise a little-endian computer.
</p><p>
So <em>if</em> the values are equal, then you can still do the exercise as-is, in
which case the first bitfield should be read as: bit 0 should be 0, in which
case the bits refer to the bit-indices from the byte at the lowest address
to the byte at the highest address. 
</p><p>
If this is all going a bit too fast for you: never mind, and simple do the
exercise as described.
</p><p>
<br><strong>Answer:</strong><br>
    The trick of this exercise is to define a <code>struct</code> using initialized
bit-fields. Once that's accomplished, define a union of two fields: your
<code>struct</code> and a <code>size_t</code>. Then use designated initialization to initialize
your union object, and display its <code>value</code> field. 
</p><p>
Written as a hexadecimal value it displays <code>c0ffeecafe</code>:
</p><p>
</p><pre>#include &lt;iostream&gt;

using namespace std;

struct Fields
{
    size_t bf_0: 1 = 0;         // field initialization according to
    size_t bf_1: 3 = 7;         // the exercise
    size_t bf_2: 4 = 15;
    size_t bf_3: 5 = 10;
    size_t bf_4: 4 = 6;
    size_t bf_5: 4 = 7;
    size_t bf_6: 4 = 15;
    size_t bf_7: 4 = 15;
    size_t bf_8: 4 = 7;
    size_t bf_9: 5 = 0;
    size_t bf_a: 2 = 3;
                                // remaining bits are 0 by default, and
                                // do not have to be set explicitly
};

union Combi                     // a union containing a Fields and a size_t
{
    Fields fields;
    size_t value;
};

int main()
{                               // see the explanation in the answer
    cout &lt;&lt; hex &lt;&lt; Combi{ .fields = Fields{} }.value &lt;&lt; '\n';
}

</pre>

<p>
<br><br>
    
</p><hr>
        <strong>Exercise 8.</strong>
        <br>
        Advanced exercise
        <br>
        Purpose of this exercise: learn to manipulate bits inside variables
<p>
In this exercise we'll have a look at how to handle bits inside an existing
<code>size_t</code> variable. Our program (assuming the compiled program has the
(default) name <code>a.out</code>) is called like this:
        </p><pre>
    ./a.out 12345 2 10
        
</pre>

    Here, the first value can be any value. In fact the value is interpreted
as a <em>heaxadecimal</em> value meaning that 
    <ul>
    <li> Each digit occupies four bits (also called a <em>nibble</em>).
    </li><li> In addition to the digits 0..9 the `digits' a..f are also valid,
where 'a' represents 10 in the decimal notation through 'f' representing 15 in
the decimal notation.
    </li></ul>
<p>
The second value represents the <em>nibble</em> offset. In the example the 5 of
12345 is at offset 0, the 1 at offset 4 (this is only true if your computer is
a little-endian computer; most computers these days are. If yours is a
big-endian computer then the offsets must be swapped: 5 at 4, 1 at 0). On a 32
bits computer the offset can at most be 7 (there are 32 / 4 = 8
nibbles). Likewise, on a 64 bits computer the offset can at most be 15. In
this program it's your responsibility to make sure that you specify a valid
value here.
</p><p>
The 3rd value is the value to store in the nibble selected  by the second
argument. Only its lowest 4 bits must be used.
</p><p>
When called as shown, the program should show this output:
        </p><pre>
    12a45
        
</pre>

<p>
Write a program using bit-manipulations to modify the 1st value. Display
the modified value.
</p><p>
Hint: insert your code in the section labeled 
        </p><pre>
    // insert your code here
        
</pre>

    in the following source file:
        <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main(int argc, char *argv[])
{
    size_t value = stoul(argv[1], 0, 16);   // initialize hexadecimal value
    size_t nibble = stoul(argv[2]);         // nibble to replace
    size_t replacement = stoul(argv[3]) % 16;   // new nibble (= 0 .. 15)

    // insert your code here

    cout &lt;&lt; hex &lt;&lt; value &lt;&lt; '\n';       // show the new value
}
        
</pre>

<p>
<br><strong>Answer:</strong><br>
    </p><pre>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main(int argc, char *argv[])
{
    size_t value = stoul(argv[1], 0, 16);   // initialize hexadecimal value
    size_t nibble = stoul(argv[2]);         // nibble to replace
    size_t replacement = stoul(argv[3]) % 16;   // new nibble (= 0 .. 15)


        // 1: clear the intended nibble

    size_t bitIdx = nibble * 4;         // bit index matching the nibble

    value &amp;= ~(15 &lt;&lt; bitIdx);           // shift 15 into place, and toggle
                                        // all bits, then clear the nibble 
                                        // to modify
    
        // 2: assign the replacement to the correct nibble

    value |= replacement &lt;&lt; bitIdx;     // only set the replacement bits


    cout &lt;&lt; hex &lt;&lt; value &lt;&lt; '\n';       // show the new value
}






</pre>

<p>
<br><br>
    
</p><p>
            
    </p><p></p><hr><p>
    
    
        
            </p><hr>
            <hr>
<ul>
    <li> <a href="https://www.icce.rug.nl/edu/1/opgaven.html">Table of Contents</a>
    </li><li> <a href="https://www.icce.rug.nl/edu/1/opgaven02.html">Next Chapter</a>
</li></ul>
<hr>


</body></html>